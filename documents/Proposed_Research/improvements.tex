\section{Improvments}
\subsection{Extension to Interprocedural Analysis}
The approach above is an intraprocedural analysis performed on the control flow graph of a method. We will also try to extend this apporach to an interprodecural analysis. When no recursion is present in the program, we will create a in-lined control flow graph where function calls are replaced by the control flow graph of the called method. Each function call creates a new copy of its control flow graph, which adds calling context to the analysis. In the case of recursion -- we will explore two possible avenues. One is to bound the depth of recursion and use the same inlining method as above. The second is to create a back-edge in the control flow graph to represent the recursion. While this results in additional infeasible paths added to our analysis as the calling context is lost, all possible control flow paths will be present, preserving the soundness of our analysis. 

\subsection{Refinement}

While our method returns a sound over-approximation of side channels up to a user-specified strength in the source code, it is not precise. This stems from the fact that not all paths in the control flow graph are feasible, and hence a detected side channel may not be exploitable in the executable program. To help mitigate this problem, we will explore combining our analysis with predicate abstraction \cite{predicate}. Predicate abstraction allows us to define a set of predicates on program variables and keep track of the possible values of those predicates through transitions of a finite state machine. In our case, we will be using the conditions of the branch statements along our witness paths as the set of predicates. Predicate abstraction will allow us to determine if the values of the predicates along the considered path are unsatisfiable. Since predicate abstraction provides an overapproximation for the possible values of the predicates, we will still conclude that some unexploitable side channels are realizable; however, our hypothesis is that predicate absraction will still be beneficial in reducing the number of unrealizable side channels reported. 

A potential hurdle in effectively using predicate abstraction to reduce the number of paths is that there may not only be a single pair of witness paths for a side channel but rather a space of potential witness paths. We would need to check the feasibility of each of these paths which in the worst case could be an exponential number. We believe that our choice to independently analyze subgraphs of the control flow will help with exponential blow-up but it could remain a problem nevertherless. Additionally, since predicate abstraction provides an over-approximation, we cannot conclude that a side channel exists even when the considered paths are found to be not be unfeasible. The only conclusion we might be able to make is that a detected side channel is infeasible. 

Another potential way to determine if a side channel is exploitable is to use a method such as symbolic execution \cite{symbolic} to obtain the path condition that must be satisfied for the considered path to be feasible.  This would allow us to obtain an accurate answer as to whether a pair of witness paths are realizable. In this case, we would be able to positvely answer that a side channel in the program is detectable within the threshold. Again, there may be an exponential number of paths making this approach infeasible in the worst case. However, once we ascertain that one particular pair of witness paths are satisfiable, we have proven the existence of an exploitable side channel in the program and do not need to continue the analysis. This allows us to postively answer the question of side channel existence. 