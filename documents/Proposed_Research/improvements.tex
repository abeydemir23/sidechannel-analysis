\section{Extensions}
\textbf{Interprocedural Analysis.} Path cost analysis, when outlined as above, is an intraprocedural analysis performed on a method's control flow graph. We will extend this approach to an interprodecural analysis. When no recursion is present in the program, we will create a in-lined control flow graph where function calls are replaced by the control flow graph of the called method. Each function call creates a new copy of its control flow graph, which adds calling context to the analysis. In the case of recursion -- we will explore two possible avenues. One is to bound the depth of recursion and use the same inlining method as above. The second is to create a back-edge in the control flow graph to represent the recursion. While this results in additional infeasible paths added to our analysis, all possible control flow paths will be present. 

\textbf{Refinement.} While our method returns an over-approximation of side channels up to a user-specified strength in the source code, it is not precise. This stems from the fact that not all paths in the control flow graph are feasible, and hence a detected side channel may not be exploitable in the executable program. To help mitigate this problem, we will explore combining our analysis with predicate abstraction \cite{predicate}. Predicate abstraction allows us to define a set of predicates on program variables and keep track of the possible values of those predicates through transitions. In our case, the predicates will be the conditions of the branch statements along our witness paths. Predicate abstraction will allow us to determine if the values of the predicates along the considered path are unsatisfiable. Since predicate abstraction provides an over-approximation for the possible values of the predicates, we will still conclude that some un-exploitable side channels are realizable; however, our hypothesis is that predicate abstraction will still be beneficial in reducing the number of unrealizable side channels reported. 

A potential hurdle in effectively using predicate abstraction to reduce the number of paths is that there may not only be a single pair of witness paths for a side channel but rather a space of potential witness paths. We would need to check the feasibility of each of these paths which in the worst case could be an exponential number. We believe that our choice to independently analyze subgraphs of the control flow will help with exponential blow-up but it could remain a problem nevertheless. Additionally, since predicate abstraction provides an over-approximation, we cannot conclude that a side channel exists even when the considered paths are found to be not be infeasible. The only conclusion we might be able to make is that a detected side channel is infeasible. 

Another potential way to determine if a side channel is exploitable is to use a method such as symbolic execution \cite{symbolic} to obtain the path condition that must be satisfied for the considered path to be feasible.  This would allow us to obtain an accurate answer as to whether a pair of witness paths are realizable. In this case, we would be able to positively answer that a side channel in the program is detectable within the threshold. Again, there may be an exponential number of paths making this approach infeasible in the worst case. However, once we ascertain that one particular pair of witness paths are satisfiable, we have proven the existence of an exploitable side channel in the program. This allows us to positively answer the question of side channel existence. 