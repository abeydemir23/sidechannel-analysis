\section{Related Work}

There has been notable previous work on static analysis for side channel detection. These include the methods presented by Pasareanu et al. \cite{smtmulti} and Bang et al. \cite{BAQ16}. Both approaches use a combination of symbolic execution and model counting to determine the probability of a particular execution path. From this, tools from information theory are used in order to determine the amount of information leaked about the value of the secret. These approaches suffer due to their reliance on symbolic execution, a heavy weight technique that does not scale to large applications like those we are considering. Our proposed method could be considered as a complimentary approach to theirs. Using our approach, we can reduce a complicated program to a potentially much smaller set of suspicious methods for which symbolic execution might be scalabe. Work of Zhang et al. on Sidebuster \cite{sidebuster} details a static approach to detecting side channels in web applications. Their work involves taint analysis to determine whether a secret value has propogated to a conditional branching statement. If it has, the number of remote procedure calls in each of the branches is compared. When the number of calls differs, the site is marked as a potential side channel and symbolic execution is run to determine its strength. Our approach strengthens and generalizes theirs by creating a symbolic cost expression for every node in the control flow graph and comparing the cost for a specific set of nodes.  In this way, our method can detect a more expressive class of side channels as opposed to only side channels caused by differing numbers of packets. Another static approach is presented by Antopolous et al. in their tool Blazer \cite{decomposition}. Their approach involves recursively paritioning the set of possible traces through the program such that all traces in a given partition take approximately the same amount of time. Their approach can be thought of as vertical -- iteratively decomposing the set of entire program traces -- while ours can be considered horizontal -- analyzing different subgraphs of the control flow graph idependently. \todo{this makes no sense to anyone else probably} Because of this, our approach is able to capture side channels that are resultant from differing costs at output nodes naturally while their entire analysis would need to be performed using a different property for each output node in the graph. Their approach also does not support recursive functions. Other types of static analysis techniques are particular to specific types of side channels, such as CacheAudit \cite{cacheaudit}, or are type-based analyses \cite{fixbyconstant,hedin}.

%Previous work on side channel detection and quantification can be broken down into static and dynamic approaches. Dynamic approaches, such as presented by Chothia et al. in their tool LeakWatch \cite{leakwatch} estimate the amount on leakage in a given program through statistical analysis \cite{formalbounds, stats} done on the repeated trials of the program using independently drawn input samples. \todo{probably remove all dynamic stuff} Our work is more closely related to other static techqniues to detecting side channels. 