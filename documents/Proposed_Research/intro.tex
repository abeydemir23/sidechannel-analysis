\section{Introduction}

Modern software systems frequently store and manipulate personal data, such as location, credit card information or medical history.  Guaranteeing the confidentiality of such private data is necessary to protect the users of these systems.  To this end, the development of software systems is guided by the dictate that a program that manipulates private data should not reveal that data.  Many practices, such as the encryption of packages over a network, aim to protect the confidentiality of private data by ensuring that an observer is unable to parse any meaningful output from the system. Under these protections, the system's main channel, the content of the network packets, does not leak information about the private data. However, serious security vulnerabilities are still possible. 

A class of information leaks, called side-channel attacks, use non-functional properties of the program's output to obtain information about private data.  Potential side channels include execution time, memory usage, size and timings of an encrypted series of packets, electromagnetic radiation and power consumption. For example, the timing and packet sizes of encrypted web trafic can leak information about what page a user has loaded. %Side channels are properties of the implementation of the algorithm, not the algorithm itself. An algorithm may be secure but some aspect of its implementation, such as an optimization, can introduce a side channel that allows an observer to gain knowledge about protected data.  

Though side channel vulnerabilities have been know for many years, they are still often neglected by developers of web applications and other software services. They are commonly thought of as impractical despite a growing number of demonstrations of realistic side channel attacks that result in a critical security vulnerability \cite{timingpractical, cachepractical, ASLRtiming}. Because of this, programmers are often unaware of the potential side channels they may be introducing to a system, especially through attempts to optimize functions that manipulate secret input. To protect sensitive user data, scalable analysis tools devoted to the detection of side channel vulnerabilities are needed. We propose a static, scalable tool based on a method's control flow graph aimed at providing a sound over-approximation of the method's side channel vulnerabilities.  Our research aims to address the following questions:

\begin{itemize}
\item[] \textbf{RQ1.} Assume we are given a set of secret variables, a type of side channel, and a method's control flow graph. Can we detect the set of branch conditions responsible for potential side channels of the given type in the method and generate a pair of witness paths in the control flow graph for each? Witness paths are paths in the control flow graph differing only on the detected branch conditions whose observable output under the given side channel differs by more than some user defined threshold. 
\item[] \textbf{RQ2.} Can we extend this intraprocedural approach to an interprocedural one? 
\item[] \textbf{RQ3.} Can we iteratively refine the detected side channels by using predicate abstraction or a symbolic execution engine to detect when one of the witness paths is infeasible?
\item[] \textbf{RQ4.} How will our technique perform on large Java programs?
\end{itemize}

Our method is motivated by the observation that sizeable class of side channels occur when the value of private data results in multiple distinct control flow paths with characteristic observables. For example, the execution time of some implementations of the modular exponentiation function used RSA encryption take time proportional to the Hamming weight of the exponent. This is due to a branch condition repeated on each bit of the exponent which leads to additional computation whenever that bit is set to 1. Our hypothesis is that it is possible to detect the presence of these side channels from a method's control flow graph. We understand that not all side channels can be characterized by the above, such as those caused by low level issues like cache behavior \cite{cache}, but we still expect our method to be valuable in detecting a large class of side channels. Our expected contributions include a scalable static analysis tool to perform this detection and an iterative method to determine whether the detected side channels are actually exploitable in the program.